import {
  createAsyncThunk,
  createSelector,
  createSlice,
  PayloadAction,
} from "@reduxjs/toolkit";
import { CardDto } from "@skill-test/data/dto/learn/CardDto";
import cardApi from "../../api/cardApi";
import { CoreState } from "../store";
import { CrudMode } from "../CrudMode";
import { LoadingState } from "../LoadingState";
import { handleThunkError } from "../reduxUtils";

export interface CardsState {
  cards: CardDto[];
  cardsLoading: LoadingState;
  cardsLoadingError?: string;

  card?: CardDto;
  cardSaveLoading: LoadingState;
  cardSaveError?: string;

  mode?: CrudMode;
}

const initialState: CardsState = {
  cards: [],
  cardsLoading: LoadingState.IDLE,
  cardSaveLoading: LoadingState.IDLE,
};

// https://www.newline.co/@bespoyasov/how-to-use-thunks-with-redux-toolkit-and-typescript--1e65fc64
export const fetchCards = createAsyncThunk<CardDto[]>(
  "cards/fetchCards",
  async (_, thunkAPI) => await handleThunkError(thunkAPI, cardApi.getCards())
);

export const createCard = createAsyncThunk<CardDto, CardDto>(
  "cards/createCard",
  async (card, thunkAPI) =>
    await handleThunkError(thunkAPI, cardApi.createCard(card))
);

export const cardsSlice = createSlice({
  name: "cards",
  initialState,
  // The `reducers` field lets us define reducers and generate associated actions
  reducers: {
    setMode: (state, { payload }: PayloadAction<CrudMode | undefined>) => {
      state.mode = payload;
    },
    editCard: (state, { payload }: PayloadAction<CardDto>) => {
      state.card = payload;
      state.mode = payload.id ? CrudMode.UPDATE : CrudMode.CREATE;
    },
    viewCard: (state, { payload }: PayloadAction<CardDto>) => {
      state.card = payload;
      state.mode = CrudMode.READ;
    },
  },
  // The `extraReducers` field lets the slice handle actions defined elsewhere, including actions generated by createAsyncThunk or in other slices.
  extraReducers: {
    // fetch cards
    [fetchCards.pending as any]: (state: CardsState) => {
      state.cards = [];
      state.cardsLoading = LoadingState.LOADING;
    },
    [fetchCards.fulfilled as any]: (
      state: CardsState,
      action: PayloadAction<CardDto[]>
    ) => {
      state.cards = action.payload;
      state.cardsLoading = LoadingState.LOADED;
    },
    [fetchCards.rejected as any]: (
      state: CardsState,
      action: PayloadAction<any>
    ) => {
      state.cardsLoadingError = action.payload;
      state.cardsLoading = LoadingState.ERROR;
    },

    // create card
    [createCard.pending as any]: (state: CardsState) => {
      state.cardSaveLoading = LoadingState.LOADING;
    },
    [createCard.fulfilled as any]: (
      state: CardsState,
      action: PayloadAction<CardDto>
    ) => {
      state.card = action.payload;
      state.cardSaveLoading = LoadingState.LOADED;
    },
    [createCard.rejected as any]: (
      state: CardsState,
      action: PayloadAction<string>
    ) => {
      state.cardSaveError = action.payload;
      state.cardSaveLoading = LoadingState.ERROR;
    },
  },
});

export const { setMode, editCard, viewCard } = cardsSlice.actions;

// The function below is called a selector and allows us to select a value from
// the state. Selectors can also be defined inline where they're used instead of
// in the slice file. For example: `useSelector((state: RootState) => state.counter.value)`
export const selectCards = createSelector(
  (state: CoreState) => ({
    cards: state.cards.cards,
    cardsLoading: state.cards.cardsLoading,
    cardsLoadingError: state.cards.cardsLoadingError,
  }),
  (state) => state
);

export const selectCardSave = createSelector(
  (state: CoreState) => ({
    mode: state.cards.mode,
    card: state.cards.card,
    cardSaveLoading: state.cards.cardSaveLoading,
    cardSaveError: state.cards.cardSaveError,
  }),
  (state) => state
);

export default cardsSlice.reducer;
