import {
  createAsyncThunk,
  createSelector,
  createSlice,
  PayloadAction,
} from "@reduxjs/toolkit";
import { CardDto } from "@skill-test/data/dto/learn/CardDto";
import { DeckDto } from "@skill-test/data/dto/learn/DeckDto";
import { getDeck, getDecks } from "../../api/deckApi";
import { fillCardWithTranslation } from "../../utils/utils";
import { DeckMode } from "../DeckMode";
import { LoadingState } from "../LoadingState";
import { CoreState } from "../store";
import { LangsState } from "./langsSlice";

export interface DecksState {
  decks: DeckDto[];
  decksLoading: LoadingState;
  decksLoadingError?: string;

  selectedDeck?: DeckDto;
  selectedDeckLoading: LoadingState;
  selectedDeckLoadingError?: string;

  mode: DeckMode;
}

const initialState: DecksState = {
  decks: [],
  decksLoading: LoadingState.IDLE,
  selectedDeckLoading: LoadingState.IDLE,
  mode: DeckMode.VIEW,
};

// https://www.newline.co/@bespoyasov/how-to-use-thunks-with-redux-toolkit-and-typescript--1e65fc64
export const fetchDecks = createAsyncThunk<DeckDto[]>(
  "decks/fetchDecks",
  async () => {
    const response = await getDecks();
    return response;
  }
);

export const fetchDeck = createAsyncThunk<DeckDto, number>(
  "decks/fetchDeck",
  async (id, { getState }) => {
    const response = await getDeck(id);
    const { langs } = getState() as { langs: LangsState };
    response.cards = response.cards.map((card) =>
      fillCardWithTranslation(card, langs.locale)
    );
    return response;
  }
);

export const decksSlice = createSlice({
  name: "decks",
  initialState,
  // The `reducers` field lets us define reducers and generate associated actions
  reducers: {
    setMode: (state, action) => {
      state.mode = action.payload;
    },
    addCard: (state, { payload }: PayloadAction<CardDto>) => {
      if (!state.selectedDeck) return;
      const idx = state.selectedDeck.cards.findIndex(
        ({ id }) => id === payload.id
      );
      if (idx === -1) {
        state.selectedDeck.cards.push(payload);
      } else {
        state.selectedDeck.cards[idx] = payload;
      }
    },
  },
  // The `extraReducers` field lets the slice handle actions defined elsewhere, including actions generated by createAsyncThunk or in other slices.
  extraReducers: {
    [fetchDecks.pending as any]: (state: DecksState) => {
      state.decks = [];
      state.decksLoading = LoadingState.LOADING;
    },
    [fetchDecks.fulfilled as any]: (
      state: DecksState,
      action: PayloadAction<DeckDto[]>
    ) => {
      state.decks = action.payload;
      state.decksLoading = LoadingState.LOADED;
    },
    [fetchDecks.rejected as any]: (
      state: DecksState,
      action: PayloadAction<any>
    ) => {
      state.decksLoadingError = action.payload;
      state.decksLoading = LoadingState.ERROR;
    },
    // ----------------------
    [fetchDeck.pending as any]: (state: DecksState) => {
      state.selectedDeck = undefined;
      state.selectedDeckLoading = LoadingState.LOADING;
    },
    [fetchDeck.fulfilled as any]: (
      state: DecksState,
      action: PayloadAction<DeckDto>
    ) => {
      state.selectedDeck = action.payload;
      state.selectedDeckLoading = LoadingState.LOADED;
    },
    [fetchDeck.rejected as any]: (
      state: DecksState,
      action: PayloadAction<string>
    ) => {
      state.selectedDeckLoadingError = action.payload;
      state.selectedDeckLoading = LoadingState.ERROR;
    },
  },
});

export const { setMode, addCard } = decksSlice.actions;

// The function below is called a selector and allows us to select a value from
// the state. Selectors can also be defined inline where they're used instead of
// in the slice file. For example: `useSelector((state: RootState) => state.counter.value)`
export const selectDecks = createSelector(
  (state: CoreState) => ({
    decks: state.decks.decks,
    decksLoading: state.decks.decksLoading,
    decksLoadingError: state.decks.decksLoadingError,
  }),
  (state) => state
);

export const selectDeck = createSelector(
  (state: CoreState) => ({
    mode: state.decks.mode,
    deck: state.decks.selectedDeck,
    deckLoading: state.decks.selectedDeckLoading,
    deckLoadingError: state.decks.selectedDeckLoadingError,
  }),
  (state) => state
);

export default decksSlice.reducer;
